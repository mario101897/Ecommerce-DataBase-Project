# The first thing I did was set up the necessary libraries and decided on the scale of the dataset. 
# Since I am simulating an e-commerce environment, 
# I needed a good variety of customers, products, suppliers, and orders.

from faker import Faker
import csv
import random
import re
from datetime import datetime

# Initializing Faker for generating realistic data
fake = Faker()

# Defining the scale of our dataset to reflect a busy e-commerce system
num_customers = 1000
num_products = 500
num_suppliers = 50
num_orders = 2500

# Parameters that will help us manage stock and order quantities realistically
max_initial_stock = 300  # The maximum initial stock for products
max_order_quantity = 10  # A reasonable cap on how much of a product a single order can contain
restock_threshold = 50   # When stock falls below this, we'll consider it time to restock

# Initially, I attempted to generate phone numbers using the .phone_number() method from the Faker class, 
# but it produced numbers without a consistent structure. 
# As a result, I had to define a custom function to generate standardized US phone numbers. 

def generate_phone_number():
    # Generate a raw phone number using Faker
    phone_number = fake.phone_number()
    
    # Remove any non-numeric characters
    cleaned = re.sub(r'[^\d]', '', phone_number)
    
    # Ensure the phone number is exactly 10 digits long
    if len(cleaned) < 10:
        cleaned = cleaned.zfill(10)  # Pad with zeros if it's too short
    elif len(cleaned) > 10:
        cleaned = cleaned[-10:]  # Keep the last 10 digits if it's too long
    
    # Format the phone number in the US standard format with a leading +1
    formatted = f"+1-{cleaned[0:3]}-{cleaned[3:6]}-{cleaned[6:]}"
    
    return formatted

# Similar to the phone numbers, I had to define a specific function to create the emails, 
# rather than using a method from the Faker class. 
# The fake.email() method generated emails that were unrelated to the context I needed.

def generate_email(first_name, last_name):
    # Combine first and last names into a single email-friendly string
    email_name = f"{first_name.lower()}{last_name.lower()}"
    
    # List of possible email domains to maintain variety
    email_domains = ['example.com', 'example.org', 'example.net']
    
    # Choose a random domain from the list
    domain = random.choice(email_domains)
    
    # Construct the full email address
    email = f"{email_name}@{domain}"
    
    return email

# CUSTUMERS TABLE

# Preparing to track unique values
unique_emails = set() # To ensure unique emails

# Creating the customers data
with open('/users/mariocardozo/documents/customers.csv', 'w', newline='') as csvfile:
    fieldnames = ['CustomerID', 'Name', 'Email', 'Address', 'PhoneNumber']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    
    for i in range(1, num_customers + 1):
        # Generate a full name using Faker
        full_name = fake.name()
        
        # Split the full name to extract the first and last names
        name_parts = full_name.split()
        first_name = name_parts[0]
        last_name = name_parts[-1]  # Using the last element as the last name
        
        writer.writerow({
            'CustomerID': i,
            'Name': full_name,  # Use the full name generated by Faker
            'Email': generate_email(first_name, last_name),  # Generate email based on first and last names
            'Address': fake.address(),
            'PhoneNumber': generate_phone_number()  # Use the function for standardized US phone numbers
        })